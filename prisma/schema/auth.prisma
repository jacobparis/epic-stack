model Organization {
  id        String   @id @default(uuid())
  name      String
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  memberships Membership[]
}

model Membership {
  id             String  @id @default(uuid())
  userId         String?
  organizationId String
  invitedById    String?

  user         User?        @relation("MembershipUser", fields: [userId], references: [id])
  invitedBy    User?        @relation("InvitedByUser", fields: [invitedById], references: [id])
  organization Organization @relation(fields: [organizationId], references: [id])
  roles        Role[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([userId])
  @@index([invitedById])
  @@index([organizationId])
}

model User {
  id                 String       @id @default(uuid())
  createdAt          DateTime     @default(now())
  updatedAt          DateTime     @updatedAt
  memberships        Membership[] @relation("MembershipUser")
  invitedMemberships Membership[] @relation("InvitedByUser")
  account            Account      @relation(fields: [accountId], references: [id])
  accountId          String

  // The following fields are app-specific and you might want to change them
  // TODO: maybe make these nullable?
  name  String?
  image UserImage?
  notes Note[]
}

model Account {
  id String @id @default(uuid())

  email    String @unique // Remove the unique constraint if you want the same email to be used for separate accounts in different orgs (like Slack)
  username String @unique // Remove this if you don't want to log in with usernames

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  password    Password?
  sessions    Session[]
  users       User[]
  connections Connection[]
}

model Password {
  accountId String @unique
  hash      String

  account Account @relation(fields: [accountId], references: [id])
}

model Connection {
  id           String @id @default(cuid())
  providerName String
  providerId   String

  createdAt DateTime @default(now())
  updatedAt DateTime @default(now())

  account   Account? @relation(fields: [accountId], references: [id])
  accountId String?

  @@unique([providerName, providerId])
}

model Session {
  id              String    @id @default(uuid())
  expirationDate  DateTime
  accounts        Account[]
  activeAccountId String? // an account-switcher would change this

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

model Permission {
  id          String @id @default(cuid())
  action      String
  entity      String
  access      String
  description String @default("")

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  roles Role[] @relation("RolePermissions")

  @@unique([action, entity, access])
}

model Role {
  id          String @id @default(cuid())
  name        String @unique
  description String @default("")

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  permissions Permission[] @relation("RolePermissions")
  memberships Membership[]
}

model Verification {
  id        String   @id @default(cuid())
  createdAt DateTime @default(now())

  /// The type of verification, e.g. "email" or "phone"
  type String

  /// The thing we're trying to verify, e.g. a user's email or phone number
  target String

  /// The secret key used to generate the otp
  secret String

  /// The algorithm used to generate the otp
  algorithm String

  /// The number of digits in the otp
  digits Int

  /// The number of seconds the otp is valid for
  period Int

  /// The valid characters for the otp
  charSet String

  /// When it's safe to delete this verification
  expirationDate DateTime?

  @@unique([target, type])
}
